'use strict';

var deepMerge = require('deepmerge');
require('array.prototype.flatmap/auto.js');
var escapeRegExp = require('escape-string-regexp');
var experimentalUtils = require('@typescript-eslint/experimental-utils');
require('object.fromentries/auto.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var deepMerge__default = /*#__PURE__*/_interopDefaultLegacy(deepMerge);
var escapeRegExp__default = /*#__PURE__*/_interopDefaultLegacy(escapeRegExp);

const config = {
    rules: {
        "functional/functional-parameters": "error",
        "functional/immutable-data": "error",
        "functional/no-class": "error",
        "functional/no-conditional-statement": "error",
        "functional/no-expression-statement": "error",
        "functional/no-let": "error",
        "functional/no-loop-statement": "error",
        "functional/no-promise-reject": "error",
        "functional/no-this-expression": "error",
        "functional/no-throw-statement": "error",
        "functional/no-try-statement": "error",
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "functional/no-method-signature": "error",
                "functional/no-mixed-type": "error",
                "functional/prefer-readonly-type": "error",
                "functional/prefer-type-literal": "error",
                "functional/no-return-void": "error",
            },
        },
    ],
};

const config$1 = {
    rules: {
        "functional/functional-parameters": "error",
    },
};

const config$2 = {
    rules: {
        "prefer-const": "error",
        "no-param-reassign": "error",
        "no-var": "error",
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "@typescript-eslint/explicit-function-return-type": [
                    "error",
                    {
                        allowExpressions: true,
                        allowTypedFunctionExpressions: true,
                        allowHigherOrderFunctions: true,
                    },
                ],
            },
        },
    ],
};

const config$3 = {
    rules: {
        "functional/no-let": "error",
        "functional/immutable-data": "error",
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "functional/no-method-signature": "warn",
                "functional/prefer-readonly-type": "error",
            },
        },
    ],
};

const config$4 = {
    rules: {
        "functional/no-throw-statement": "error",
        "functional/no-try-statement": "error",
    },
};

const config$5 = {
    rules: {
        "functional/no-this-expression": "error",
        "functional/no-class": "error",
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "functional/no-mixed-type": "error",
                "functional/prefer-type-literal": "error",
            },
        },
    ],
};

const config$6 = {
    rules: {
        "functional/no-expression-statement": "error",
        "functional/no-conditional-statement": "error",
        "functional/no-loop-statement": "error",
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "functional/no-return-void": "error",
            },
        },
    ],
};

const config$7 = deepMerge.all([
    config$1,
    config$3,
    config$4,
    config$5,
    config$6,
]);

const config$8 = deepMerge__default['default'](config$7, {
    rules: {
        "functional/no-conditional-statement": "off",
        "functional/no-expression-statement": "off",
        "functional/no-try-statement": "off",
        "functional/functional-parameters": [
            "error",
            {
                enforceParameterCount: false,
            },
        ],
    },
});

// Conditionally loaded TypeScript but only if it is avaliable.
var ts = (() => {
    try {
        return require("typescript");
    }
    catch (error) {
        return undefined;
    }
})();

/**
 * @file Functions that typeguard the given node/type.
 */
/*
 * Node type guards.
 */
function isArrayExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ArrayExpression;
}
function isAssignmentExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.AssignmentExpression;
}
function isAssignmentPattern(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.AssignmentPattern;
}
function isBlockStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.BlockStatement;
}
function isCallExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.CallExpression;
}
/**
 * Is the given node a class node?
 *
 * It doesn't matter what type of class.
 */
function isClassLike(node) {
    return (node.type === experimentalUtils.AST_NODE_TYPES.ClassDeclaration ||
        node.type === experimentalUtils.AST_NODE_TYPES.ClassExpression);
}
function isExpressionStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ExpressionStatement;
}
function isFunctionDeclaration(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.FunctionDeclaration;
}
/**
 * Is the given node a function expression node?
 *
 * It doesn't matter what type of function expression.
 */
function isFunctionExpressionLike(node) {
    return (node.type === experimentalUtils.AST_NODE_TYPES.FunctionExpression ||
        node.type === experimentalUtils.AST_NODE_TYPES.ArrowFunctionExpression);
}
/**
 * Is the given node a function node?
 *
 * It doesn't matter what type of function.
 */
function isFunctionLike(node) {
    return isFunctionDeclaration(node) || isFunctionExpressionLike(node);
}
function isIdentifier(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.Identifier;
}
function isIfStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.IfStatement;
}
function isMemberExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.MemberExpression;
}
function isMethodDefinition(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.MethodDefinition;
}
function isNewExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.NewExpression;
}
function isProperty(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.Property;
}
function isRestElement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.RestElement;
}
function isReturnStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ReturnStatement;
}
function isThisExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ThisExpression;
}
function isTSArrayType(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSArrayType;
}
function isTSIndexSignature(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSIndexSignature;
}
function isTSInterfaceBody(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSInterfaceBody;
}
function isTSNullKeyword(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSNullKeyword;
}
function isTSParameterProperty(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSParameterProperty;
}
function isTSPropertySignature(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSPropertySignature;
}
function isTSTupleType(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSTupleType;
}
function isTSTypeAnnotation(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSTypeAnnotation;
}
function isTSTypeLiteral(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSTypeLiteral;
}
function isTSTypeOperator(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSTypeOperator;
}
function isTSTypeReference(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSTypeReference;
}
function isTSUndefinedKeyword(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSUndefinedKeyword;
}
function isTSVoidKeyword(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSVoidKeyword;
}
function isUnaryExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.UnaryExpression;
}
function isVariableDeclaration(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.VariableDeclaration;
}
function hasID(node) {
    return Object.prototype.hasOwnProperty.call(node, "id");
}
function hasKey(node) {
    return Object.prototype.hasOwnProperty.call(node, "key");
}
/*
 * TS types type guards.
 */
function isUnionType(type) {
    return ts !== undefined && type.flags === ts.TypeFlags.Union;
}
function isArrayType(type, assumeType = false, node = null) {
    return assumeType === true && type === null
        ? node !== null
        : type !== null &&
            ((type.symbol && type.symbol.name === "Array") ||
                (isUnionType(type) &&
                    type.types.some((t) => isArrayType(t, false, null))));
}
function isArrayConstructorType(type, assumeType = false, node = null) {
    return assumeType === true && type === null
        ? node !== null && isIdentifier(node) && node.name === "Array"
        : type !== null &&
            ((type.symbol && type.symbol.name === "ArrayConstructor") ||
                (isUnionType(type) &&
                    type.types.some((t) => isArrayConstructorType(t, false, null))));
}
function isObjectConstructorType(type, assumeType = false, node = null) {
    return assumeType === true && type === null
        ? node !== null && isIdentifier(node) && node.name === "Object"
        : type !== null &&
            ((type.symbol && type.symbol.name === "ObjectConstructor") ||
                (isUnionType(type) &&
                    type.types.some((t) => isObjectConstructorType(t, false, null))));
}

/**
 * Return the first ancestor that meets the given check criteria.
 */
function getAncestorOfType(checker, node, child = null) {
    return checker(node, child)
        ? node
        : node.parent == undefined
            ? null
            : getAncestorOfType(checker, node.parent, node);
}
/**
 * Test if the given node is in a function's body.
 */
function inFunctionBody(node) {
    return (getAncestorOfType((n, c) => isFunctionLike(n) && n.body === c, node) !== null);
}
/**
 * Test if the given node is in a class.
 */
function inClass(node) {
    return getAncestorOfType(isClassLike, node) !== null;
}
/**
 * Test if the given node is in a TS Property Signature.
 */
function inInterface(node) {
    return getAncestorOfType(isTSInterfaceBody, node) !== null;
}
/**
 * Test if the given node is in a Constructor.
 */
function inConstructor(node) {
    const methodDefinition = getAncestorOfType(isMethodDefinition, node);
    return (methodDefinition !== null &&
        isIdentifier(methodDefinition.key) &&
        methodDefinition.key.name === "constructor");
}
/**
 * Is the given node in the return type.
 */
function isInReturnType(node) {
    return (getAncestorOfType((n) => n.parent != undefined &&
        isFunctionLike(n.parent) &&
        n.parent.returnType === n, node) !== null);
}
/**
 * Is the given identifier a property of an object?
 */
function isPropertyAccess(node) {
    return (node.parent !== undefined &&
        isMemberExpression(node.parent) &&
        node.parent.property === node);
}
/**
 * Is the given identifier a property name?
 */
function isPropertyName(node) {
    return (node.parent !== undefined &&
        isProperty(node.parent) &&
        node.parent.key === node);
}
/**
 * Is the given function an IIFE?
 */
function isIIFE(node) {
    return (isFunctionExpressionLike(node) &&
        node.parent !== undefined &&
        isCallExpression(node.parent) &&
        node.parent.callee === node);
}

// Polyfill.
const allowLocalMutationOptionSchema = {
    type: "object",
    properties: {
        allowLocalMutation: {
            type: "boolean",
        },
    },
    additionalProperties: false,
};
const ignorePatternOptionSchema = {
    type: "object",
    properties: {
        ignorePattern: {
            type: ["string", "array"],
            items: {
                type: "string",
            },
        },
    },
    additionalProperties: false,
};
const ignoreAccessorPatternOptionSchema = {
    type: "object",
    properties: {
        ignoreAccessorPattern: {
            type: ["string", "array"],
            items: {
                type: "string",
            },
        },
    },
    additionalProperties: false,
};
const ignoreClassOptionSchema = {
    type: "object",
    properties: {
        ignoreClass: {
            type: "boolean",
        },
    },
    additionalProperties: false,
};
const ignoreInterfaceOptionSchema = {
    type: "object",
    properties: {
        ignoreInterface: {
            type: "boolean",
        },
    },
    additionalProperties: false,
};
/**
 * Get the identifier text of the given node.
 */
function getNodeIdentifierText(node, context) {
    return node === undefined || node === null
        ? undefined
        : isIdentifier(node)
            ? node.name
            : hasID(node)
                ? getNodeIdentifierText(node.id, context)
                : hasKey(node)
                    ? getNodeIdentifierText(node.key, context)
                    : isAssignmentExpression(node)
                        ? getNodeIdentifierText(node.left, context)
                        : isMemberExpression(node)
                            ? `${getNodeIdentifierText(node.object, context)}.${getNodeIdentifierText(node.property, context)}`
                            : isThisExpression(node)
                                ? "this"
                                : isUnaryExpression(node)
                                    ? getNodeIdentifierText(node.argument, context)
                                    : isExpressionStatement(node)
                                        ? context.getSourceCode().getText(node)
                                        : isTSArrayType(node) ||
                                            isTSIndexSignature(node) ||
                                            isTSTupleType(node) ||
                                            isTSTypeAnnotation(node) ||
                                            isTSTypeLiteral(node) ||
                                            isTSTypeReference(node)
                                            ? getNodeIdentifierText(node.parent, context)
                                            : undefined;
}
/**
 * Get all the identifier texts of the given node.
 */
function getNodeIdentifierTexts(node, context) {
    return (isVariableDeclaration(node)
        ? node.declarations.flatMap((declarator) => getNodeIdentifierText(declarator, context))
        : [getNodeIdentifierText(node, context)]).filter((text) => text !== undefined);
}
/**
 * Should the given text be allowed?
 *
 * Test using the given pattern(s).
 */
function shouldIgnoreViaPattern(text, ignorePattern) {
    const patterns = Array.isArray(ignorePattern)
        ? ignorePattern
        : [ignorePattern];
    // One or more patterns match?
    return patterns.some((pattern) => new RegExp(pattern).test(text));
}
/**
 * Recursive callback of `shouldIgnoreViaAccessorPattern`.
 *
 * This function not be called from anywhere else.
 *
 * Does the given text match the given pattern.
 */
function accessorPatternMatch([pattern, ...remainingPatternParts], textParts, allowExtra = false) {
    return pattern === undefined
        ? allowExtra || textParts.length === 0
        : // Match any depth (including 0)?
            pattern === "**"
                ? textParts.length === 0
                    ? accessorPatternMatch(remainingPatternParts, [], allowExtra)
                    : Array.from({ length: textParts.length })
                        .map((_element, index) => index)
                        .some((offset) => accessorPatternMatch(remainingPatternParts, textParts.slice(offset), true))
                : // Match anything?
                    pattern === "*"
                        ? textParts.length > 0 &&
                            accessorPatternMatch(remainingPatternParts, textParts.slice(1), allowExtra)
                        : // Text matches pattern?
                            new RegExp(`^${escapeRegExp__default['default'](pattern).replace(/\\\*/g, ".*")}$`).test(textParts[0]) &&
                                accessorPatternMatch(remainingPatternParts, textParts.slice(1), allowExtra);
}
/**
 * Should the given text be allowed?
 *
 * Test using the given accessor pattern(s).
 */
function shouldIgnoreViaAccessorPattern(text, ignorePattern) {
    const patterns = Array.isArray(ignorePattern)
        ? ignorePattern
        : [ignorePattern];
    // One or more patterns match?
    return patterns.some((pattern) => accessorPatternMatch(pattern.split("."), text.split(".")));
}
/**
 * Should the given node be allowed base off the following rule options?
 *
 * - IgnoreAccessorPatternOption.
 * - IgnoreClassOption.
 * - IgnoreInterfaceOption.
 * - IgnorePatternOption.
 * - AllowLocalMutationOption.
 */
function shouldIgnore(node, context, options) {
    return (
    // Allow if in a function and allowLocalMutation is set.
    (options.allowLocalMutation === true && inFunctionBody(node)) ||
        // Ignore if in a class and ignoreClass is set.
        (options.ignoreClass === true && inClass(node)) ||
        // Ignore if in an interface and ignoreInterface is set.
        (options.ignoreInterface === true && inInterface(node)) ||
        ((texts) => texts.length > 0
            ? // Ignore if ignorePattern is set and a pattern matches.
                (options.ignorePattern !== undefined &&
                    texts.every((text) => shouldIgnoreViaPattern(text, options.ignorePattern))) ||
                    // Ignore if ignoreAccessorPattern is set and an accessor pattern matches.
                    (options.ignoreAccessorPattern !== undefined &&
                        texts.every((text) => shouldIgnoreViaAccessorPattern(text, options.ignoreAccessorPattern)))
            : false)(getNodeIdentifierTexts(node, context)));
}

const version = "3.0.2";

// Polyfill.
// This function can't be functional as it needs to interact with 3rd-party
// libraries that aren't functional.
/* eslint-disable functional/no-return-void, functional/no-conditional-statement, functional/no-expression-statement */
/**
 * Create a function that processes common options and then runs the given
 * check.
 */
function checkNode(check, context, options) {
    return (node) => {
        if (!options || !shouldIgnore(node, context, options)) {
            const result = check(node, context, options);
            result.descriptors.forEach((descriptor) => result.context.report(descriptor));
        }
    };
}
/* eslint-enable functional/no-return-void, functional/no-conditional-statement, functional/no-expression-statement */
/**
 * Create a rule.
 */
function createRule(name, meta, defaultOptions, ruleFunctionsMap) {
    return experimentalUtils.ESLintUtils.RuleCreator((name) => `https://github.com/jonaskello/eslint-plugin-functional/blob/v${version}/docs/rules/${name}.md`)({
        name,
        meta,
        defaultOptions: [defaultOptions],
        create: (context, [options]) => Object.fromEntries(Object.entries(ruleFunctionsMap).map(([nodeSelector, ruleFunction]) => [
            nodeSelector,
            checkNode(ruleFunction, context, options),
        ])),
    });
}
/**
 * Get the type of the the given node.
 */
function getTypeOfNode(node, context) {
    const { parserServices } = context;
    return parserServices === undefined ||
        parserServices.program === undefined ||
        parserServices.esTreeNodeToTSNodeMap === undefined
        ? null
        : parserServices.program
            .getTypeChecker()
            .getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node));
}

// The name of this rule.
const name = "functional-parameters";
// The schema for the rule options.
const schema = [
    deepMerge.all([
        ignorePatternOptionSchema,
        {
            type: "object",
            properties: {
                allowRestParameter: {
                    type: "boolean",
                },
                allowArgumentsKeyword: {
                    type: "boolean",
                },
                enforceParameterCount: {
                    oneOf: [
                        {
                            type: "boolean",
                            enum: [false],
                        },
                        {
                            type: "string",
                            enum: ["atLeastOne", "exactlyOne"],
                        },
                        {
                            type: "object",
                            properties: {
                                count: {
                                    type: "string",
                                    enum: ["atLeastOne", "exactlyOne"],
                                },
                                ignoreIIFE: {
                                    type: "boolean",
                                },
                            },
                            additionalProperties: false,
                        },
                    ],
                },
            },
            additionalProperties: false,
        },
    ]),
];
// The default options for the rule.
const defaultOptions = {
    allowRestParameter: false,
    allowArgumentsKeyword: false,
    enforceParameterCount: {
        count: "atLeastOne",
        ignoreIIFE: true,
    },
};
// The possible error messages.
const errorMessages = {
    restParam: "Unexpected rest parameter. Use a regular parameter of type array instead.",
    arguments: "Unexpected use of `arguments`. Use regular function arguments instead.",
    paramCountAtLeastOne: "Functions must have at least one parameter.",
    paramCountExactlyOne: "Functions must have exactly one parameter.",
};
// The meta data for this rule.
const meta = {
    type: "suggestion",
    docs: {
        description: "Enforce functional parameters.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages,
    schema,
};
/**
 * Get the rest parameter violations.
 */
function getRestParamViolations(allowRestParameter, node) {
    return !allowRestParameter &&
        node.params.length > 0 &&
        isRestElement(node.params[node.params.length - 1])
        ? [
            {
                node: node.params[node.params.length - 1],
                messageId: "restParam",
            },
        ]
        : [];
}
/**
 * Get the parameter count violations.
 */
function getParamCountViolations(enforceParameterCount, node) {
    if (enforceParameterCount === false ||
        (node.params.length === 0 &&
            typeof enforceParameterCount === "object" &&
            enforceParameterCount.ignoreIIFE &&
            isIIFE(node))) {
        return [];
    }
    else if (node.params.length === 0 &&
        (enforceParameterCount === "atLeastOne" ||
            (typeof enforceParameterCount === "object" &&
                enforceParameterCount.count === "atLeastOne"))) {
        return [
            {
                node,
                messageId: "paramCountAtLeastOne",
            },
        ];
    }
    else if (node.params.length !== 1 &&
        (enforceParameterCount === "exactlyOne" ||
            (typeof enforceParameterCount === "object" &&
                enforceParameterCount.count === "exactlyOne"))) {
        return [
            {
                node,
                messageId: "paramCountExactlyOne",
            },
        ];
    }
    else {
        return [];
    }
}
/**
 * Check if the given function node has a reset parameter this rule.
 */
function checkFunction(node, context, options) {
    return {
        context,
        descriptors: [
            ...getRestParamViolations(options.allowRestParameter, node),
            ...getParamCountViolations(options.enforceParameterCount, node),
        ],
    };
}
/**
 * Check if the given identifier is for the "arguments" keyword.
 */
function checkIdentifier(node, context, options) {
    return {
        context,
        descriptors: !options.allowArgumentsKeyword &&
            node.name === "arguments" &&
            !isPropertyName(node) &&
            !isPropertyAccess(node)
            ? [
                {
                    node,
                    messageId: "arguments",
                },
            ]
            : [],
    };
}
// Create the rule.
const rule = createRule(name, meta, defaultOptions, {
    FunctionDeclaration: checkFunction,
    FunctionExpression: checkFunction,
    ArrowFunctionExpression: checkFunction,
    Identifier: checkIdentifier,
});

/**
 * Returns a function that checks if the given value is the same as the expected
 * value.
 */
function isExpected(expected) {
    return (actual) => actual === expected;
}
/**
 * Does the given ExpressionStatement specify directive prologues.
 */
function isDirectivePrologue(node) {
    return (node.expression.type === experimentalUtils.AST_NODE_TYPES.Literal &&
        typeof node.expression.value === "string" &&
        node.expression.value.startsWith("use "));
}

// The name of this rule.
const name$1 = "immutable-data";
// The schema for the rule options.
const schema$1 = [
    deepMerge.all([
        ignorePatternOptionSchema,
        ignoreAccessorPatternOptionSchema,
        {
            type: "object",
            properties: {
                ignoreImmediateMutation: {
                    type: "boolean",
                },
                assumeTypes: {
                    oneOf: [
                        {
                            type: "boolean",
                        },
                        {
                            type: "object",
                            properties: {
                                forArrays: {
                                    type: "boolean",
                                },
                                forObjects: {
                                    type: "boolean",
                                },
                            },
                            additionalProperties: false,
                        },
                    ],
                },
            },
            additionalProperties: false,
        },
    ]),
];
// The default options for the rule.
const defaultOptions$1 = {
    ignoreImmediateMutation: true,
    assumeTypes: {
        forArrays: true,
        forObjects: true,
    },
};
// The possible error messages.
const errorMessages$1 = {
    generic: "Modifying an existing object/array is not allowed.",
    object: "Modifying properties of existing object not allowed.",
    array: "Modifying an array is not allowed.",
};
// The meta data for this rule.
const meta$1 = {
    type: "suggestion",
    docs: {
        description: "Enforce treating data as immutable.",
        category: "Best Practices",
        recommended: "error",
    },
    messages: errorMessages$1,
    schema: schema$1,
};
/**
 * Array methods that mutate an array.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Methods#Mutator_methods
 */
const arrayMutatorMethods = [
    "copyWithin",
    "fill",
    "pop",
    "push",
    "reverse",
    "shift",
    "sort",
    "splice",
    "unshift",
];
/**
 * Array methods that return a new object (or array) without mutating the original.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Methods#Accessor_methods
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Iteration_methods
 */
const arrayNewObjectReturningMethods = [
    "concat",
    "slice",
    "filter",
    "map",
    "reduce",
    "reduceRight",
];
/**
 * Array constructor functions that create a new array.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Methods
 */
const arrayConstructorFunctions = ["from", "of"];
/**
 * Object constructor functions that mutate an object.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#Methods_of_the_Object_constructor
 */
const objectConstructorMutatorFunctions = [
    "assign",
    "defineProperties",
    "defineProperty",
    "setPrototypeOf",
];
/**
 * Check if the given assignment expression violates this rule.
 */
function checkAssignmentExpression(node, context) {
    return {
        context,
        descriptors: isMemberExpression(node.left) &&
            // Allow if in a constructor - allow for field initialization.
            !inConstructor(node)
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
/**
 * Check if the given node violates this rule.
 */
function checkUnaryExpression(node, context) {
    return {
        context,
        descriptors: node.operator === "delete" && isMemberExpression(node.argument)
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
/**
 * Check if the given node violates this rule.
 */
function checkUpdateExpression(node, context, options) {
    return {
        context,
        descriptors: isMemberExpression(node.argument) &&
            !shouldIgnore(node.argument, context, options)
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
/**
 * Check if the given the given MemberExpression is part of a chain and
 * immediately follows a method/function call that returns a new array.
 *
 * If this is the case, then the given MemberExpression is allowed to be
 * a mutator method call.
 */
function isInChainCallAndFollowsNew(node, context, assumeArrayTypes) {
    return (
    // Check for: [0, 1, 2]
    isArrayExpression(node.object) ||
        // Check for: new Array()
        (isNewExpression(node.object) &&
            isArrayConstructorType(
            // `isNewExpression` type guard doesn't seem to be working? so use `as`.
            getTypeOfNode(node.object.callee, context), assumeArrayTypes, node.object.callee)) ||
        (isCallExpression(node.object) &&
            isMemberExpression(node.object.callee) &&
            isIdentifier(node.object.callee.property) &&
            // Check for: Array.from(iterable)
            ((arrayConstructorFunctions.some(isExpected(node.object.callee.property.name)) &&
                isArrayConstructorType(getTypeOfNode(node.object.callee.object, context), assumeArrayTypes, node.object.callee.object)) ||
                // Check for: array.slice(0)
                arrayNewObjectReturningMethods.some(isExpected(node.object.callee.property.name)))));
}
/**
 * Check if the given node violates this rule.
 */
function checkCallExpression(node, context, options) {
    const assumeTypesForArrays = options.assumeTypes === true ||
        (options.assumeTypes !== false && options.assumeTypes.forArrays === true);
    const assumeTypesForObjects = options.assumeTypes === true ||
        (options.assumeTypes !== false && options.assumeTypes.forObjects === true);
    return {
        context,
        descriptors: 
        // Potential object mutation?
        isMemberExpression(node.callee) && isIdentifier(node.callee.property)
            ? // Potential array mutation?
                // Check if allowed here - this cannot be automatically checked beforehand.
                !shouldIgnore(node.callee.object, context, options) &&
                    arrayMutatorMethods.some((m) => m ===
                        node.callee
                            .property.name) &&
                    (!options.ignoreImmediateMutation ||
                        !isInChainCallAndFollowsNew(node.callee, context, assumeTypesForArrays)) &&
                    isArrayType(getTypeOfNode(node.callee.object, context), assumeTypesForArrays, node.callee.object)
                    ? [{ node, messageId: "array" }]
                    : // Potential non-array object mutation (ex. Object.assign on identifier)?
                        objectConstructorMutatorFunctions.some((m) => m ===
                            node.callee
                                .property.name) &&
                            node.arguments.length >= 2 &&
                            (isIdentifier(node.arguments[0]) ||
                                isMemberExpression(node.arguments[0])) &&
                            // Check if allowed here - this cannot be automatically checked beforehand.
                            !shouldIgnore(node.arguments[0], context, options) &&
                            isObjectConstructorType(getTypeOfNode(node.callee.object, context), assumeTypesForObjects, node.callee.object)
                            ? [{ node, messageId: "object" }]
                            : []
            : [],
    };
}
// Create the rule.
const rule$1 = createRule(name$1, meta$1, defaultOptions$1, {
    AssignmentExpression: checkAssignmentExpression,
    UnaryExpression: checkUnaryExpression,
    UpdateExpression: checkUpdateExpression,
    CallExpression: checkCallExpression,
});

// The name of this rule.
const name$2 = "no-class";
// The schema for the rule options.
const schema$2 = [];
// The default options for the rule.
const defaultOptions$2 = {};
// The possible error messages.
const errorMessages$2 = {
    generic: "Unexpected class, use functions not classes.",
};
// The meta data for this rule.
const meta$2 = {
    type: "suggestion",
    docs: {
        description: "Disallow classes.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$2,
    schema: schema$2,
};
/**
 * Check if the given class node violates this rule.
 */
function checkClass(node, context) {
    // All class nodes violate this rule.
    return { context, descriptors: [{ node, messageId: "generic" }] };
}
// Create the rule.
const rule$2 = createRule(name$2, meta$2, defaultOptions$2, { ClassDeclaration: checkClass, ClassExpression: checkClass });

// The name of this rule.
const name$3 = "no-conditional-statement";
// The schema for the rule options.
const schema$3 = [
    {
        type: "object",
        properties: {
            allowReturningBranches: {
                oneOf: [
                    {
                        type: "boolean",
                    },
                    {
                        type: "string",
                        enum: ["ifExhaustive"],
                    },
                ],
            },
        },
        additionalProperties: false,
    },
];
// The default options for the rule.
const defaultOptions$3 = { allowReturningBranches: false };
// The possible error messages.
const errorMessages$3 = {
    incompleteBranch: "Incomplete branch, every branch in a conditional statement must contain a return statement.",
    incompleteIf: "Incomplete if, it must have an else statement and every branch must contain a return statement.",
    incompleteSwitch: "Incomplete switch, it must have an default case and every case must contain a return statement.",
    unexpectedIf: "Unexpected if, use a conditional expression (ternary operator) instead.",
    unexpectedSwitch: "Unexpected switch, use a conditional expression (ternary operator) instead.",
};
// The meta data for this rule.
const meta$3 = {
    type: "suggestion",
    docs: {
        description: "Disallow conditional statements.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$3,
    schema: schema$3,
};
/**
 * Get all of the violations in the given if statement assuming if statements
 * are allowed.
 */
function getIfBranchViolations(node) {
    const branches = [node.consequent, node.alternate];
    const violations = branches.filter((branch) => branch !== null &&
        !isReturnStatement(branch) &&
        !(isBlockStatement(branch) &&
            branch.body.some((statement) => isReturnStatement(statement) ||
                // Another instance of this rule will check nested if statements.
                isIfStatement(statement))) &&
        !isIfStatement(branch));
    return violations.flatMap((node) => [
        { node, messageId: "incompleteBranch" },
    ]);
}
/**
 * Get all of the violations in the given switch statement assuming switch
 * statements are allowed.
 */
function getSwitchViolations(node) {
    const violations = node.cases.filter((branch) => branch.consequent.length !== 0 &&
        !branch.consequent.some(isReturnStatement) &&
        !(branch.consequent.every(isBlockStatement) &&
            branch.consequent[branch.consequent.length - 1].body.some(isReturnStatement)));
    return violations.flatMap((node) => [
        { node, messageId: "incompleteBranch" },
    ]);
}
/**
 * Does the given if statement violate this rule if it must be exhaustive.
 */
function isExhaustiveIfViolation(node) {
    return node.alternate === null;
}
/**
 * Does the given switch statement violate this rule if it must be exhaustive.
 */
function isExhaustiveSwitchViolation(node) {
    return (
    // No cases defined.
    node.cases.length === 0 ||
        // No default case defined.
        node.cases.every((c) => c.test !== null));
}
/**
 * Check if the given IfStatement violates this rule.
 */
function checkIfStatement(node, context, options) {
    return {
        context,
        descriptors: options.allowReturningBranches
            ? options.allowReturningBranches === "ifExhaustive"
                ? isExhaustiveIfViolation(node)
                    ? [{ node, messageId: "incompleteIf" }]
                    : getIfBranchViolations(node)
                : getIfBranchViolations(node)
            : [{ node, messageId: "unexpectedIf" }],
    };
}
/**
 * Check if the given SwitchStatement violates this rule.
 */
function checkSwitchStatement(node, context, options) {
    return {
        context,
        descriptors: options.allowReturningBranches
            ? options.allowReturningBranches === "ifExhaustive"
                ? isExhaustiveSwitchViolation(node)
                    ? [{ node, messageId: "incompleteSwitch" }]
                    : getSwitchViolations(node)
                : getSwitchViolations(node)
            : [{ node, messageId: "unexpectedSwitch" }],
    };
}
// Create the rule.
const rule$3 = createRule(name$3, meta$3, defaultOptions$3, {
    IfStatement: checkIfStatement,
    SwitchStatement: checkSwitchStatement,
});

// The name of this rule.
const name$4 = "no-expression-statement";
// The schema for the rule options.
const schema$4 = [ignorePatternOptionSchema];
// The default options for the rule.
const defaultOptions$4 = {};
// The possible error messages.
const errorMessages$4 = {
    generic: "Using expressions to cause side-effects not allowed.",
};
// The meta data for this rule.
const meta$4 = {
    type: "suggestion",
    docs: {
        description: "Disallow expression statements.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$4,
    schema: schema$4,
};
/**
 * Check if the given ExpressionStatement violates this rule.
 */
function checkExpressionStatement(node, context) {
    return {
        context,
        descriptors: 
        // Allow specifying directive prologues.
        isDirectivePrologue(node) ? [] : [{ node, messageId: "generic" }],
    };
}
// Create the rule.
const rule$4 = createRule(name$4, meta$4, defaultOptions$4, {
    ExpressionStatement: checkExpressionStatement,
});

// The name of this rule.
const name$5 = "no-let";
// The schema for the rule options.
const schema$5 = [
    deepMerge.all([allowLocalMutationOptionSchema, ignorePatternOptionSchema]),
];
// The default options for the rule.
const defaultOptions$5 = {
    allowLocalMutation: false,
};
// The possible error messages.
const errorMessages$5 = {
    generic: "Unexpected let, use const instead.",
};
// The meta data for this rule.
const meta$5 = {
    type: "suggestion",
    docs: {
        description: "Disallow mutable variables.",
        category: "Best Practices",
        recommended: "error",
    },
    messages: errorMessages$5,
    fixable: "code",
    schema: schema$5,
};
/**
 * Check if the given VariableDeclaration violates this rule.
 */
function checkVariableDeclaration(node, context) {
    return {
        context,
        descriptors: node.kind === "let" ? [{ node, messageId: "generic" }] : [],
    };
}
// Create the rule.
const rule$5 = createRule(name$5, meta$5, defaultOptions$5, {
    VariableDeclaration: checkVariableDeclaration,
});

// The name of this rule.
const name$6 = "no-loop-statement";
// The schema for the rule options.
const schema$6 = [];
// The default options for the rule.
const defaultOptions$6 = {};
// The possible error messages.
const errorMessages$6 = {
    generic: "Unexpected loop, use map or reduce instead.",
};
// The meta data for this rule.
const meta$6 = {
    type: "suggestion",
    docs: {
        description: "Disallow imperative loops.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$6,
    schema: schema$6,
};
/**
 * Check if the given loop violates this rule.
 */
function checkLoop(node, context) {
    // All loops violate this rule.
    return { context, descriptors: [{ node, messageId: "generic" }] };
}
// Create the rule.
const rule$6 = createRule(name$6, meta$6, defaultOptions$6, {
    ForStatement: checkLoop,
    ForInStatement: checkLoop,
    ForOfStatement: checkLoop,
    WhileStatement: checkLoop,
    DoWhileStatement: checkLoop,
});

// The name of this rule.
const name$7 = "no-method-signature";
// The schema for the rule options.
const schema$7 = [];
// The default options for the rule.
const defaultOptions$7 = {};
// The possible error messages.
const errorMessages$7 = {
    generic: "Method signature is mutable, use property signature with readonly modifier instead.",
};
// The meta data for this rule.
const meta$7 = {
    type: "suggestion",
    docs: {
        description: "Prefer property signatures with readonly modifiers over method signatures.",
        category: "Best Practices",
        recommended: "error",
    },
    messages: errorMessages$7,
    schema: schema$7,
};
/**
 * Check if the given TSMethodSignature violates this rule.
 */
function checkTSMethodSignature(node, context) {
    // All TS method signatures violate this rule.
    return { context, descriptors: [{ node, messageId: "generic" }] };
}
// Create the rule.
const rule$7 = createRule(name$7, meta$7, defaultOptions$7, {
    TSMethodSignature: checkTSMethodSignature,
});

// The name of this rule.
const name$8 = "no-mixed-type";
// The schema for the rule options.
const schema$8 = [
    {
        type: "object",
        properties: {
            checkInterfaces: {
                type: "boolean",
            },
            checkTypeLiterals: {
                type: "boolean",
            },
        },
        additionalProperties: false,
    },
];
// The default options for the rule.
const defaultOptions$8 = {
    checkInterfaces: true,
    checkTypeLiterals: true,
};
// The possible error messages.
const errorMessages$8 = {
    generic: "Only the same kind of members allowed in types.",
};
// The meta data for this rule.
const meta$8 = {
    type: "suggestion",
    docs: {
        description: "Restrict types so that only members of the same kind of are allowed in them.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$8,
    schema: schema$8,
};
/**
 * Does the given type elements violate the rule.
 */
function hasTypeElementViolations(typeElements) {
    const typeElementsTypeInfo = typeElements.map((member) => ({
        type: member.type,
        typeAnnotation: isTSPropertySignature(member) && member.typeAnnotation !== undefined
            ? member.typeAnnotation.typeAnnotation.type
            : undefined,
    }));
    return typeElementsTypeInfo.reduce((carry, member) => ({
        prevMemberType: member.type,
        prevMemberTypeAnnotation: member.typeAnnotation,
        violations: 
        // Not the first property in the interface.
        carry.prevMemberType !== undefined &&
            // And different property type to previous property.
            (carry.prevMemberType !== member.type ||
                // Or annotationed with a different type annotation.
                (carry.prevMemberTypeAnnotation !== member.typeAnnotation &&
                    // Where one of the properties is a annotationed as a function.
                    (carry.prevMemberTypeAnnotation === experimentalUtils.AST_NODE_TYPES.TSFunctionType ||
                        member.typeAnnotation === experimentalUtils.AST_NODE_TYPES.TSFunctionType))),
    }), {
        prevMemberType: undefined,
        prevMemberTypeAnnotation: undefined,
        violations: false,
    }).violations;
}
/**
 * Check if the given TSInterfaceDeclaration violates this rule.
 */
function checkTSInterfaceDeclaration(node, context, options) {
    return {
        context,
        descriptors: options.checkInterfaces && hasTypeElementViolations(node.body.body)
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
/**
 * Check if the given TSTypeAliasDeclaration violates this rule.
 */
function checkTSTypeAliasDeclaration(node, context, options) {
    return {
        context,
        descriptors: options.checkTypeLiterals &&
            isTSTypeLiteral(node.typeAnnotation) &&
            hasTypeElementViolations(node.typeAnnotation.members)
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
// Create the rule.
const rule$8 = createRule(name$8, meta$8, defaultOptions$8, {
    TSInterfaceDeclaration: checkTSInterfaceDeclaration,
    TSTypeAliasDeclaration: checkTSTypeAliasDeclaration,
});

// The name of this rule.
const name$9 = "no-promise-reject";
// The schema for the rule options.
const schema$9 = [];
// The default options for the rule.
const defaultOptions$9 = {};
// The possible error messages.
const errorMessages$9 = {
    generic: "Unexpected reject, return an error instead.",
};
// The meta data for this rule.
const meta$9 = {
    type: "suggestion",
    docs: {
        description: "Disallow try-catch[-finally] and try-finally patterns.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$9,
    schema: schema$9,
};
/**
 * Check if the given CallExpression violates this rule.
 */
function checkCallExpression$1(node, context) {
    return {
        context,
        descriptors: isMemberExpression(node.callee) &&
            isIdentifier(node.callee.object) &&
            isIdentifier(node.callee.property) &&
            node.callee.object.name === "Promise" &&
            node.callee.property.name === "reject"
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
// Create the rule.
const rule$9 = createRule(name$9, meta$9, defaultOptions$9, {
    CallExpression: checkCallExpression$1,
});

// The name of this rule.
const name$a = "no-return-void";
// The schema for the rule options.
const schema$a = [
    {
        type: "object",
        properties: {
            allowNull: {
                type: "boolean",
            },
            allowUndefined: {
                type: "boolean",
            },
        },
        additionalProperties: false,
    },
];
// The default options for the rule.
const defaultOptions$a = {
    allowNull: true,
    allowUndefined: true,
};
// The possible error messages.
const errorMessages$a = {
    generic: "Function must return a value.",
};
// The meta data for this rule.
const meta$a = {
    type: "suggestion",
    docs: {
        description: "Disallow functions that don't return anything.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$a,
    schema: schema$a,
};
/**
 * Check if the given function node violates this rule.
 */
function checkFunction$1(node, context, options) {
    return {
        context,
        descriptors: node.returnType !== undefined &&
            (isTSVoidKeyword(node.returnType.typeAnnotation) ||
                (!options.allowNull &&
                    isTSNullKeyword(node.returnType.typeAnnotation)) ||
                (!options.allowUndefined &&
                    isTSUndefinedKeyword(node.returnType.typeAnnotation)))
            ? [{ node: node.returnType, messageId: "generic" }]
            : [],
    };
}
// Create the rule.
const rule$a = createRule(name$a, meta$a, defaultOptions$a, {
    FunctionDeclaration: checkFunction$1,
    FunctionExpression: checkFunction$1,
    ArrowFunctionExpression: checkFunction$1,
    TSFunctionType: checkFunction$1,
});

// The name of this rule.
const name$b = "no-this-expression";
// The schema for the rule options.
const schema$b = [];
// The default options for the rule.
const defaultOptions$b = {};
// The possible error messages.
const errorMessages$b = {
    generic: "Unexpected this, use functions not classes.",
};
// The meta data for this rule.
const meta$b = {
    type: "suggestion",
    docs: {
        description: "Disallow this access.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$b,
    schema: schema$b,
};
/**
 * Check if the given ThisExpression violates this rule.
 */
function checkThisExpression(node, context) {
    // All throw statements violate this rule.
    return { context, descriptors: [{ node, messageId: "generic" }] };
}
// Create the rule.
const rule$b = createRule(name$b, meta$b, defaultOptions$b, {
    ThisExpression: checkThisExpression,
});

// The name of this rule.
const name$c = "no-throw-statement";
// The schema for the rule options.
const schema$c = [];
// The default options for the rule.
const defaultOptions$c = {};
// The possible error messages.
const errorMessages$c = {
    generic: "Unexpected throw, throwing exceptions is not functional.",
};
// The meta data for this rule.
const meta$c = {
    type: "suggestion",
    docs: {
        description: "Disallow throwing exceptions.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$c,
    schema: schema$c,
};
/**
 * Check if the given ThrowStatement violates this rule.
 */
function checkThrowStatement(node, context) {
    // All throw statements violate this rule.
    return { context, descriptors: [{ node, messageId: "generic" }] };
}
// Create the rule.
const rule$c = createRule(name$c, meta$c, defaultOptions$c, {
    ThrowStatement: checkThrowStatement,
});

// The name of this rule.
const name$d = "no-try-statement";
// The schema for the rule options.
const schema$d = [
    {
        type: "object",
        properties: {
            allowCatch: {
                type: "boolean",
            },
            allowFinally: {
                type: "boolean",
            },
        },
        additionalProperties: false,
    },
];
// The default options for the rule.
const defaultOptions$d = {
    allowCatch: false,
    allowFinally: false,
};
// The possible error messages.
const errorMessages$d = {
    catch: "Unexpected try-catch, this pattern is not functional.",
    finally: "Unexpected try-finally, this pattern is not functional.",
};
// The meta data for this rule.
const meta$d = {
    type: "suggestion",
    docs: {
        description: "Disallow try-catch[-finally] and try-finally patterns.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$d,
    schema: schema$d,
};
/**
 * Check if the given TryStatement violates this rule.
 */
function checkTryStatement(node, context, options) {
    return {
        context,
        descriptors: !options.allowCatch && node.handler !== null
            ? [{ node, messageId: "catch" }]
            : !options.allowFinally && node.finalizer !== null
                ? [{ node, messageId: "finally" }]
                : [],
    };
}
// Create the rule.
const rule$d = createRule(name$d, meta$d, defaultOptions$d, {
    TryStatement: checkTryStatement,
});

// Polyfill.
// The name of this rule.
const name$e = "prefer-readonly-type";
// The schema for the rule options.
const schema$e = [
    deepMerge.all([
        allowLocalMutationOptionSchema,
        ignorePatternOptionSchema,
        ignoreClassOptionSchema,
        ignoreInterfaceOptionSchema,
        {
            type: "object",
            properties: {
                allowMutableReturnType: {
                    type: "boolean",
                },
                checkImplicit: {
                    type: "boolean",
                },
                ignoreCollections: {
                    type: "boolean",
                },
            },
            additionalProperties: false,
        },
    ]),
];
// The default options for the rule.
const defaultOptions$e = {
    checkImplicit: false,
    ignoreClass: false,
    ignoreInterface: false,
    ignoreCollections: false,
    allowLocalMutation: false,
    allowMutableReturnType: false,
};
// The possible error messages.
const errorMessages$e = {
    array: "Only readonly arrays allowed.",
    implicit: "Implicitly a mutable array. Only readonly arrays allowed.",
    property: "A readonly modifier is required.",
    tuple: "Only readonly tuples allowed.",
    type: "Only readonly types allowed.",
};
// The meta data for this rule.
const meta$e = {
    type: "suggestion",
    docs: {
        description: "Prefer readonly array over mutable arrays.",
        category: "Best Practices",
        recommended: "error",
    },
    messages: errorMessages$e,
    fixable: "code",
    schema: schema$e,
};
const mutableToImmutableTypes = new Map([
    ["Array", "ReadonlyArray"],
    ["Map", "ReadonlyMap"],
    ["Set", "ReadonlySet"],
]);
const mutableTypeRegex = new RegExp(`^${Array.from(mutableToImmutableTypes.keys()).join("|")}$`);
/**
 * Check if the given ArrayType or TupleType violates this rule.
 */
function checkArrayOrTupleType(node, context, options) {
    if (options.ignoreCollections) {
        return {
            context,
            descriptors: [],
        };
    }
    else {
        return {
            context,
            descriptors: (!node.parent ||
                !isTSTypeOperator(node.parent) ||
                node.parent.operator !== "readonly") &&
                (!options.allowMutableReturnType || !isInReturnType(node))
                ? [
                    {
                        node,
                        messageId: isTSTupleType(node) ? "tuple" : "array",
                        fix: node.parent && isTSArrayType(node.parent)
                            ? (fixer) => [
                                fixer.insertTextBefore(node, "(readonly "),
                                fixer.insertTextAfter(node, ")"),
                            ]
                            : (fixer) => fixer.insertTextBefore(node, "readonly "),
                    },
                ]
                : [],
        };
    }
}
/**
 * Check if the given TSMappedType violates this rule.
 */
function checkMappedType(node, context) {
    return {
        context,
        descriptors: node.readonly
            ? []
            : [
                {
                    node,
                    messageId: "property",
                    fix: (fixer) => fixer.insertTextBeforeRange([node.range[0] + 1, node.range[1]], " readonly"),
                },
            ],
    };
}
/**
 * Check if the given TypeReference violates this rule.
 */
function checkTypeReference(node, context, options) {
    if (isIdentifier(node.typeName)) {
        if (options.ignoreCollections &&
            node.typeName.name.match(mutableTypeRegex)) {
            return {
                context,
                descriptors: [],
            };
        }
        else {
            const immutableType = mutableToImmutableTypes.get(node.typeName.name);
            return {
                context,
                descriptors: immutableType &&
                    (!options.allowMutableReturnType || !isInReturnType(node))
                    ? [
                        {
                            node,
                            messageId: "type",
                            fix: (fixer) => fixer.replaceText(node.typeName, immutableType),
                        },
                    ]
                    : [],
            };
        }
    }
    else {
        return {
            context,
            descriptors: [],
        };
    }
}
/**
 * Check if the given property/signature node violates this rule.
 */
function checkProperty(node, context) {
    return {
        context,
        descriptors: node.readonly
            ? []
            : [
                {
                    node,
                    messageId: "property",
                    fix: isTSIndexSignature(node)
                        ? (fixer) => fixer.insertTextBefore(node, "readonly ")
                        : isTSParameterProperty(node)
                            ? (fixer) => fixer.insertTextBefore(node.parameter, "readonly ")
                            : (fixer) => fixer.insertTextBefore(node.key, "readonly "),
                },
            ],
    };
}
/**
 * Check if the given TypeReference violates this rule.
 */
function checkImplicitType(node, context, options) {
    if (options.checkImplicit) {
        const declarators = isFunctionLike(node)
            ? node.params
                .map((param) => isAssignmentPattern(param)
                ? {
                    id: param.left,
                    init: param.right,
                    node: param,
                }
                : undefined)
                .filter((param) => param !== undefined)
            : node.declarations.map((declaration) => ({
                id: declaration.id,
                init: declaration.init,
                node: declaration,
            }));
        return {
            context,
            descriptors: declarators.flatMap((declarator) => isIdentifier(declarator.id) &&
                declarator.id.typeAnnotation === undefined &&
                declarator.init !== null &&
                isArrayType(getTypeOfNode(declarator.init, context)) &&
                !options.ignoreCollections
                ? [
                    {
                        node: declarator.node,
                        messageId: "implicit",
                        fix: (fixer) => fixer.insertTextAfter(declarator.id, ": readonly unknown[]"),
                    },
                ]
                : []),
        };
    }
    else {
        return {
            context,
            descriptors: [],
        };
    }
}
// Create the rule.
const rule$e = createRule(name$e, meta$e, defaultOptions$e, {
    ArrowFunctionExpression: checkImplicitType,
    ClassProperty: checkProperty,
    FunctionDeclaration: checkImplicitType,
    FunctionExpression: checkImplicitType,
    TSArrayType: checkArrayOrTupleType,
    TSIndexSignature: checkProperty,
    TSParameterProperty: checkProperty,
    TSPropertySignature: checkProperty,
    TSTupleType: checkArrayOrTupleType,
    TSMappedType: checkMappedType,
    TSTypeReference: checkTypeReference,
    VariableDeclaration: checkImplicitType,
});

// The name of this rule.
const name$f = "prefer-type-literal";
// The schema for the rule options.
const schema$f = [ignorePatternOptionSchema];
// The default options for the rule.
const defaultOptions$f = {};
// The possible error messages.
const errorMessages$f = {
    generic: "Unexpected interface, use a type literal instead.",
};
// The meta data for this rule.
const meta$f = {
    type: "suggestion",
    docs: {
        description: "Prefer Type Literals over Interfaces.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$f,
    fixable: "code",
    schema: schema$f,
};
/**
 * Check if the given interface node violates this rule.
 */
function checkInterface(node, context) {
    return {
        context,
        descriptors: [
            {
                node,
                messageId: "generic",
                fix: node.extends === undefined ||
                    node.extends.every((type) => isIdentifier(type.expression))
                    ? (fixer) => [
                        fixer.replaceTextRange([node.range[0], node.range[0] + "interface".length], "type"),
                        fixer.insertTextBefore(node.body, "= "),
                        ...(node.extends === undefined
                            ? []
                            : [
                                fixer.replaceTextRange([node.id.range[1], node.body.range[0]], " "),
                                ...node.extends.map((type) => fixer.insertTextBefore(node.body, `${type.expression.name} & `)),
                            ]),
                        fixer.insertTextAfter(node, ";"),
                    ]
                    : undefined,
            },
        ],
    };
}
// Create the rule.
const rule$f = createRule(name$f, meta$f, defaultOptions$f, {
    TSInterfaceDeclaration: checkInterface,
});

/**
 * All of the custom rules.
 */
const rules = {
    [name]: rule,
    [name$1]: rule$1,
    [name$2]: rule$2,
    [name$3]: rule$3,
    [name$4]: rule$4,
    [name$5]: rule$5,
    [name$6]: rule$6,
    [name$7]: rule$7,
    [name$8]: rule$8,
    [name$9]: rule$9,
    [name$a]: rule$a,
    [name$b]: rule$b,
    [name$c]: rule$c,
    [name$d]: rule$d,
    [name$e]: rule$e,
    [name$f]: rule$f,
};

const config$9 = {
    rules,
    configs: {
        all: config,
        recommended: config$7,
        "external-recommended": config$2,
        lite: config$8,
        "no-mutations": config$3,
        "no-exceptions": config$4,
        "no-object-orientation": config$5,
        "no-statements": config$6,
        currying: config$1,
    },
};

module.exports = config$9;
